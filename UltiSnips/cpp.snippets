snippet d4
int dx[] = {1,0,-1,0};
int dy[] = {0,1,0,-1};
endsnippet 
snippet d8
int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};
int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};
endsnippet
snippet d6
int dx[2][6]={{-1,0,1,1,0,-1},{-1,0,1,1,0,-1}};  
int dy[2][6]={{ 0,1,0,-1,-1,-1},{1,1,1,0,-1,0}};
endsnippet
snippet cpp
#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define all(x) (x).begin(),(x).end()
#define eb emplace_back
using namespace std;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vvl = vector<vector<long long>>; using vs = vector<string>;
using pl = pair<long long, long long>;
template <typename T> inline bool chmin(T& a, const T& b) {bool compare = a > b; if (a > b) a = b; return compare;}
template <typename T> inline bool chmax(T& a, const T& b) {bool compare = a < b; if (a < b) a = b; return compare;}
template<class T>using rp_queue=priority_queue<T,vector<T>,greater<T>>;
template <typename T> T gcd(T a, T b) {if (b == 0)return a; else return gcd(b, a % b);}
template <typename T> inline T lcm(T a, T b) {return a /gcd(a, b)*b;}
const ll INF = 1LL << 60;
const ld PI = acos(-1);
void yes(){cout<<"Yes"<<endl;}
void no(){cout<<"No"<<endl;}
void yesno(bool f){if(f)yes();else no();}
template <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec);
template <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr);
template <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec);
template <class OStream, class T, class U> OStream &operator<<(OStream &os, const pair<T, U> &pa);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec);
template <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa);
template <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp);
template <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp);
template <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl);
 
template <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec) { os << '['; for (auto v : vec) os << v << ','; os << ']'; return os; }
template <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr) { os << '['; for (auto v : arr) os << v << ','; os << ']'; return os; }
template <class... T> std::istream &operator>>(std::istream &is, std::tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }
template <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl) { os << '('; std::apply([&os](auto &&... args) { ((os << args << ','), ...);}, tpl); return os << ')'; }
template <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec) { os << "deq["; for (auto v : vec) os << v << ','; os << ']'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa) { return os << '(' << pa.first << ',' << pa.second << ')'; }
template <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << "=>" << v.second << ','; os << '}'; return os; }
template <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp) { os << '{'; for (auto v : mp) os << v.first << "=>" << v.second << ','; os << '}'; return os; }
#ifdef LOCAL
const string COLOR_RESET = "\033[0m", BRIGHT_GREEN = "\033[1;32m", BRIGHT_RED = "\033[1;31m", BRIGHT_CYAN = "\033[1;36m", NORMAL_CROSSED = "\033[0;9;37m", RED_BACKGROUND = "\033[1;41m", NORMAL_FAINT = "\033[0;2m";
#define dbg(x) std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << " = " << (x) << NORMAL_FAINT << " (L" << __LINE__ << ") " << __FILE__ << COLOR_RESET << std::endl
#define dbgif(cond, x) ((cond) ? std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << " = " << (x) << NORMAL_FAINT << " (L" << __LINE__ << ") " << __FILE__ << COLOR_RESET << std::endl : std::cerr)
#else
#define dbg(x) ((void)0)
#define dbgif(cond, x) ((void)0)
#endif
void solve(){
	$0
}
int main(){
	cin.tie(nullptr);
	ios_base::sync_with_stdio(false);
	cout<<fixed<<setprecision(15);
	int num_tc = 1;
	//cin >> num_tc;
	rep(tc,num_tc){
		//cout << "Case #" << tc+1 << ": " ;// << endl;
		solve();
	}
}
endsnippet
snippet modint
#include <atcoder/modint>
using namespace atcoder;
using mint = modint1000000007;
using mint = modint998244353;
endsnippet

snippet Sieve
struct Sieve {
	std::vector<int> min_factor;
	std::vector<int> primes;
	Sieve(int MAXN) : min_factor(MAXN + 1) {
		for (int d = 2; d <= MAXN; d++) {
			if (!min_factor[d]) {
				min_factor[d] = d;
				primes.emplace_back(d);
			}
			for (const auto &p : primes) {
				if (p > min_factor[d] or d * p > MAXN) break;
				min_factor[d * p] = p;
			}
		}
	}
	// Prime factorization for 1 <= x <= MAXN^2
	template <class T> std::map<T, int> factorize(T x) const {
		std::map<T, int> ret;
		assert(x > 0 and
				x <= ((long long)min_factor.size() - 1) * ((long long)min_factor.size() - 1));
		for (const auto &p : primes) {
			if (x < T(min_factor.size())) break;
			while (!(x % p)) x /= p, ret[p]++;
		}
		if (x >= T(min_factor.size())) ret[x]++, x = 1;
		while (x > 1) ret[min_factor[x]]++, x /= min_factor[x];
		return ret;
	}
	// Enumerate divisors of 1 <= x <= MAXN^2
	template <class T> std::vector<T> divisors(T x) const {
		std::vector<T> ret{1};
		for (const auto p : factorize(x)) {
			int n = ret.size();
			for (int i = 0; i < n; i++) {
				for (T a = 1, d = 1; d <= p.second; d++) {
					a *= p.first;
					ret.push_back(ret[i] * a);
				}
			}
		}
		return ret; // NOT sorted
	}
	// Euler phi functions of divisors of given x
	template <class T> std::map<T, T> euler_of_divisors(T x) const {
		assert(x >= 1);
		std::map<T, T> ret;
		ret[1] = 1;
		std::vector<T> divs{1};
		for (auto p : factorize(x)) {
			int n = ret.size();
			for (int i = 0; i < n; i++) {
				ret[divs[i] * p.first] = ret[divs[i]] * (p.first - 1);
				divs.push_back(divs[i] * p.first);
				for (T a = divs[i] * p.first, d = 1; d < p.second; a *= p.first, d++) {
					ret[a * p.first] = ret[a] * p.first;
					divs.push_back(a * p.first);
				}
			}
		}
		return ret;
	}
	// Moebius function Table, (-1)^{# of different prime factors} for square-free x
	std::vector<int> GenerateMoebiusFunctionTable() const {
		std::vector<int> ret(min_factor.size());
		for (unsigned i = 1; i < min_factor.size(); i++) {
			if (i == 1) {
				ret[i] = 1;
			} else if ((i / min_factor[i]) % min_factor[i] == 0) {
				ret[i] = 0;
			} else {
				ret[i] = -ret[i / min_factor[i]];
			}
		}
		return ret;
	}
	//Calculate [0^K, 1^K, ..., nmax^K] in O(nmax)
	template <class MODINT> std::vector<MODINT> enumerate_kth_pows(long long K, int nmax) const {
		assert(nmax < int(min_factor.size()));
		assert(K >= 0);
		if (K == 0) return std::vector<MODINT>(nmax + 1, 1);
		std::vector<MODINT> ret(nmax + 1);
		ret[0] = 0, ret[1] = 1;
		for (int n = 2; n <= nmax; n++) {
			if (min_factor[n] == n) {
				ret[n] = MODINT(n).pow(K);
			} else {
				ret[n] = ret[n / min_factor[n]] * ret[min_factor[n]];
			}
		}
		return ret;
	}
};
//Sieve sieve(1<<20);
endsnippet
snippet Mo
struct Mo {
	int n;
	vector< pair< int, int > > lr;

	explicit Mo(int n) : n(n) {}

	void add(int l, int r) { /* [l, r) */
		lr.emplace_back(l, r);
	}

	template< typename AL, typename AR, typename EL, typename ER, typename O >
		void build(const AL &add_left, const AR &add_right, const EL &erase_left, const ER &erase_right, const O &out) {
			int q = (int) lr.size();
			int bs = n / min< int >(n, sqrt(q));
			vector< int > ord(q);
			iota(begin(ord), end(ord), 0);
			sort(begin(ord), end(ord), [&](int a, int b) {
					int ablock = lr[a].first / bs, bblock = lr[b].first / bs;
					if(ablock != bblock) return ablock < bblock;
					return (ablock & 1) ? lr[a].second > lr[b].second : lr[a].second < lr[b].second;
					});
			int l = 0, r = 0;
			for(auto idx : ord) {
				while(l > lr[idx].first) add_left(--l);
				while(r < lr[idx].second) add_right(r++);
				while(l < lr[idx].first) erase_left(l++);
				while(r > lr[idx].second) erase_right(--r);
				out(idx);
			}
		}

	template< typename A, typename E, typename O >
		void build(const A &add, const E &erase, const O &out) {
			build(add, add, erase, erase, out);
		}
};
endsnippet
