snippet d4
int dx[] = {1,0,-1,0};
int dy[] = {0,1,0,-1};
endsnippet 
snippet d8
int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};
int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};
endsnippet
snippet d6
int dx[2][6]={{-1,0,1,1,0,-1},{-1,0,1,1,0,-1}};  
int dy[2][6]={{ 0,1,0,-1,-1,-1},{1,1,1,0,-1,0}};
endsnippet
snippet cpp
#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define all(x) (x).begin(),(x).end()
#define eb emplace_back
using namespace std;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vvl = vector<vector<long long>>; using vs = vector<string>;
using pl = pair<long long, long long>;
template <typename T> inline bool chmin(T& a, const T& b) {bool compare = a > b; if (a > b) a = b; return compare;}
template <typename T> inline bool chmax(T& a, const T& b) {bool compare = a < b; if (a < b) a = b; return compare;}
template<class T>using rp_queue=priority_queue<T,vector<T>,greater<T>>;
template <typename T> T gcd(T a, T b) {if (b == 0)return a; else return gcd(b, a % b);}
template <typename T> inline T lcm(T a, T b) {return a /gcd(a, b)*b;}
const ll INF = 1LL << 60;
const ld PI = acos(-1);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec);
template <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr);
template <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec);
template <class OStream, class T, class U> OStream &operator<<(OStream &os, const pair<T, U> &pa);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec);
template <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec);
template <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa);
template <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp);
template <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp);
template <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl);
 
template <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec) { os << '['; for (auto v : vec) os << v << ','; os << ']'; return os; }
template <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr) { os << '['; for (auto v : arr) os << v << ','; os << ']'; return os; }
template <class... T> std::istream &operator>>(std::istream &is, std::tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }
template <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl) { os << '('; std::apply([&os](auto &&... args) { ((os << args << ','), ...);}, tpl); return os << ')'; }
template <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec) { os << "deq["; for (auto v : vec) os << v << ','; os << ']'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }
template <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa) { return os << '(' << pa.first << ',' << pa.second << ')'; }
template <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << "=>" << v.second << ','; os << '}'; return os; }
template <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp) { os << '{'; for (auto v : mp) os << v.first << "=>" << v.second << ','; os << '}'; return os; }
#ifdef LOCAL
const string COLOR_RESET = "\033[0m", BRIGHT_GREEN = "\033[1;32m", BRIGHT_RED = "\033[1;31m", BRIGHT_CYAN = "\033[1;36m", NORMAL_CROSSED = "\033[0;9;37m", RED_BACKGROUND = "\033[1;41m", NORMAL_FAINT = "\033[0;2m";
#define dbg(x) std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << " = " << (x) << NORMAL_FAINT << " (L" << __LINE__ << ") " << __FILE__ << COLOR_RESET << std::endl
#define dbgif(cond, x) ((cond) ? std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << " = " << (x) << NORMAL_FAINT << " (L" << __LINE__ << ") " << __FILE__ << COLOR_RESET << std::endl : std::cerr)
#else
#define dbg(x) ((void)0)
#define dbgif(cond, x) ((void)0)
#endif
void solve();
int main(){
	cin.tie(nullptr);
	ios_base::sync_with_stdio(false);
	cout<<fixed<<setprecision(15);
	int num_tc = 1;
	//cin >> num_tc;
	rep(tc,num_tc){
		//cout << "Case #" << tc+1 << ": " ;// << endl;
		solve();
	}
}
//見切り発車で実装しては行けない．頭の中でコードが完全に出来上がるまで書き始めるな．
void solve(){
	$0
}
endsnippet
snippet modint
#include <atcoder/modint>
using mint = atcoder::modint1000000007;
using mint = atcoder::modint998244353;
endsnippet

snippet Sieve
struct Sieve {
	std::vector<int> min_factor;
	std::vector<int> primes;
	Sieve(int MAXN) : min_factor(MAXN + 1) {
		for (int d = 2; d <= MAXN; d++) {
			if (!min_factor[d]) {
				min_factor[d] = d;
				primes.emplace_back(d);
			}
			for (const auto &p : primes) {
				if (p > min_factor[d] or d * p > MAXN) break;
				min_factor[d * p] = p;
			}
		}
	}
	// Prime factorization for 1 <= x <= MAXN^2
	template <class T> std::map<T, int> factorize(T x) const {
		std::map<T, int> ret;
		assert(x > 0 and
				x <= ((long long)min_factor.size() - 1) * ((long long)min_factor.size() - 1));
		for (const auto &p : primes) {
			if (x < T(min_factor.size())) break;
			while (!(x % p)) x /= p, ret[p]++;
		}
		if (x >= T(min_factor.size())) ret[x]++, x = 1;
		while (x > 1) ret[min_factor[x]]++, x /= min_factor[x];
		return ret;
	}
	// Enumerate divisors of 1 <= x <= MAXN^2
	template <class T> std::vector<T> divisors(T x) const {
		std::vector<T> ret{1};
		for (const auto p : factorize(x)) {
			int n = ret.size();
			for (int i = 0; i < n; i++) {
				for (T a = 1, d = 1; d <= p.second; d++) {
					a *= p.first;
					ret.push_back(ret[i] * a);
				}
			}
		}
		return ret; // NOT sorted
	}
	// Euler phi functions of divisors of given x
	template <class T> std::map<T, T> euler_of_divisors(T x) const {
		assert(x >= 1);
		std::map<T, T> ret;
		ret[1] = 1;
		std::vector<T> divs{1};
		for (auto p : factorize(x)) {
			int n = ret.size();
			for (int i = 0; i < n; i++) {
				ret[divs[i] * p.first] = ret[divs[i]] * (p.first - 1);
				divs.push_back(divs[i] * p.first);
				for (T a = divs[i] * p.first, d = 1; d < p.second; a *= p.first, d++) {
					ret[a * p.first] = ret[a] * p.first;
					divs.push_back(a * p.first);
				}
			}
		}
		return ret;
	}
	// Moebius function Table, (-1)^{# of different prime factors} for square-free x
	std::vector<int> GenerateMoebiusFunctionTable() const {
		std::vector<int> ret(min_factor.size());
		for (unsigned i = 1; i < min_factor.size(); i++) {
			if (i == 1) {
				ret[i] = 1;
			} else if ((i / min_factor[i]) % min_factor[i] == 0) {
				ret[i] = 0;
			} else {
				ret[i] = -ret[i / min_factor[i]];
			}
		}
		return ret;
	}
	//Calculate [0^K, 1^K, ..., nmax^K] in O(nmax)
	template <class MODINT> std::vector<MODINT> enumerate_kth_pows(long long K, int nmax) const {
		assert(nmax < int(min_factor.size()));
		assert(K >= 0);
		if (K == 0) return std::vector<MODINT>(nmax + 1, 1);
		std::vector<MODINT> ret(nmax + 1);
		ret[0] = 0, ret[1] = 1;
		for (int n = 2; n <= nmax; n++) {
			if (min_factor[n] == n) {
				ret[n] = MODINT(n).pow(K);
			} else {
				ret[n] = ret[n / min_factor[n]] * ret[min_factor[n]];
			}
		}
		return ret;
	}
};
//Sieve sieve(1<<20);
endsnippet
snippet Mo
struct Mo {
	int n;
	vector< pair< int, int > > lr;

	explicit Mo(int n) : n(n) {}

	void add(int l, int r) { /* [l, r) */
		lr.emplace_back(l, r);
	}

	template< typename AL, typename AR, typename EL, typename ER, typename O >
		void build(const AL &add_left, const AR &add_right, const EL &erase_left, const ER &erase_right, const O &out) {
			int q = (int) lr.size();
			int bs = n / min< int >(n, sqrt(q));
			vector< int > ord(q);
			iota(begin(ord), end(ord), 0);
			sort(begin(ord), end(ord), [&](int a, int b) {
					int ablock = lr[a].first / bs, bblock = lr[b].first / bs;
					if(ablock != bblock) return ablock < bblock;
					return (ablock & 1) ? lr[a].second > lr[b].second : lr[a].second < lr[b].second;
					});
			int l = 0, r = 0;
			for(auto idx : ord) {
				while(l > lr[idx].first) add_left(--l);
				while(r < lr[idx].second) add_right(r++);
				while(l < lr[idx].first) erase_left(l++);
				while(r > lr[idx].second) erase_right(--r);
				out(idx);
			}
		}

	template< typename A, typename E, typename O >
		void build(const A &add, const E &erase, const O &out) {
			build(add, add, erase, erase, out);
		}
};
endsnippet
snippet sum2D
template<class T>
struct sum2D{
  int H,W;
  vector<vector<T>> data;
  sum2D(int _H,int _W):data(_H+1,vector<T>(_W+1,0)),H(_H),W(_W){}
  void add(int x,int y,T z){
    x++;
    y++;
    assert (1<=x&&x<=H&&1<=y&&y<=W);
    data[x][y]+=z;
  }
  void build(){
    for(int i=1;i<=H;i++){
      for(int j=1;j<=W;j++){
        data[i][j]+=data[i][j-1]+data[i-1][j]-data[i-1][j-1];
      }
    }
  }
  T sum(int sx,int gx,int sy,int gy){
    return (data[gx][gy]-data[gx][sy]-data[sx][gy]+data[sx][sy]);
  }
};
endsnippet
snippet Comb
template<typename T>
struct Comb{
  private:
    T modinv(int i){
      int n = inv.size();
      while(n<=i){
        inv.push_back(-inv[T::mod()%n]*(T::mod()/n));
        n++;
      }
      return inv[i];
    }
     T modfact(int i){
      int n = fac.size();
      while(n<=i){
        fac.push_back(fac.back()*n);
        n++;
      }
      return fac[i];
    }
     T modinvfact(int i){
       int n = finv.size();
       while(n<=i){
         finv.push_back(finv.back()*modinv(n));
         n++;
       }
       return finv[i];
     }
  public:
    vector<T> fac,finv,inv;
    Comb():fac({1,1}),finv({1,1}),inv({0,1}) {}
    T nPk(int n,int k){
      if(n<0||n<k||k<0)return 0;
      return modfact(n)*modinvfact(n-k);
    }
    T nCk(int n,int k){
      if(n<0||n<k||k<0)return 0;
      return nPk(n,k)*modinvfact(k);
    }
    T nHk(int n,int k){
      return nCk(n+k-1,k);
    }
};
endsnippet
snippet factor 
using  ull = unsigned long long;
ull modmul(ull a, ull b, ull M) {
	ll ret = a * b - M * ull(1.L / M * a * b);
	return ret + M * (ret < 0) - M * (ret >= (ll)M);
}
ull modpow(ull b, ull e, ull mod) {
	ull ans = 1;
	for (; e; b = modmul(b, b, mod), e /= 2)
		if (e & 1) ans = modmul(ans, b, mod);
	return ans;
}
bool isPrime(ull n) {
	if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;
	ull A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},
		s = __builtin_ctzll(n-1), d = n >> s;
	for (ull a : A) {   // ^ count trailing zeroes
		ull p = modpow(a%n, d, n), i = s;
		while (p != 1 && p != n - 1 && a % n && i--)
			p = modmul(p, p, n);
		if (p != n-1 && i != s) return 0;
	}
	return 1;
}
ull pollard(ull n) {
	ull x = 0, y = 0, t = 30, prd = 2, i = 1, q;
	auto f = [&](ull x) { return modmul(x, x, n) + i; };
	while (t++ % 40 || __gcd(prd, n) == 1) {
		if (x == y) x = ++i, y = f(x);
		if ((q = modmul(prd, max(x,y) - min(x,y), n))) prd = q;
		x = f(x), y = f(f(y));
	}
	return __gcd(prd, n);
}
//sortされているとは限らない
vector<ull> factor(ull n) {
	if (n == 1) return {};
	if (isPrime(n)) return {n};
	ull x = pollard(n);
	auto l = factor(x), r = factor(n / x);
	l.insert(l.end(), all(r));
	return l;
}
endsnippet
snippet parser
struct parser{
	using State  = string::const_iterator;
	string S;
	State it;
	parser(const string &_S):S(_S){
		it = S.begin();
	}
	void consume(const char &c){
		if(*it==c){
			it++;
			return;
		}
		cerr << "error!\n";
		cerr << c << endl;
		cerr << *it << endl;
		cerr << S << '\n';
		cerr << it - S.begin() << endl;
		exit(0);
	}
};

endsnippet
snippet HLD
struct HLDecomposition {
private:
    int root,N;
    vector<vector<int>>G;
    vector<int>stsize, parent, pathtop, in, out;

    void BuildStsize(int i, int p) {
        parent[i] = p, stsize[i] = 1;
        for(auto j:G[i]) {
            if(j==p) {
                if(j==G[i].back()) break;
                else swap(j,G[i].back());
            }
            BuildStsize(j,i);
            stsize[i] += stsize[j];
            if(stsize[j] > stsize[G[i][0]]) swap(j,G[i][0]);
        }
    }

    void BuildPath(int i, int p, int &time) {
        in[i] = time++;
        for(auto j:G[i]) {
            if(p==j) continue;
            pathtop[j] = (j==G[i][0] ? pathtop[i]:j);
            BuildPath(j,i,time);
        }
        out[i] = time;
    }

public:
    HLDecomposition(vector<vector<int>>&rin, int root_ = 0) : root(root_), N(rin.size()),G(rin) {
        stsize.assign(N,0);
        parent.assign(N,-1);
        pathtop.assign(N,-1);
        in.assign(N,-1), out.assign(N,-1);

        int tm = 0;
        BuildStsize(root, -1);
        pathtop[root] = root;
        BuildPath(root, -1, tm);
    }
    
    int idx(int a) {
        return in[a];
    }

    int lca(int a, int b) {
        int pa = pathtop[a], pb = pathtop[b];
        while(pathtop[a] != pathtop[b]) {
            if(in[pa] > in[pb]) {
                a = parent[pa], pa = pathtop[a];
            }
            else {
                b = parent[pb], pb = pathtop[b];
            }
        }
        if(in[a]>in[b]) swap(a,b);
        return a;
    }

    /// @brief パスクエリを処理する
    /// @param a 頂点a
    /// @param b 頂点b
    /// @param func [&](int l, int r) {処理内容}
    /// @note 辺クエリの場合、最後のfaucへの引数を、(in[a]+1,in[b]+1)にする
    void path_query(int a, int b, const function<void(int, int)>&func) {
        int pa = pathtop[a], pb = pathtop[b];
        while(pathtop[a] != pathtop[b]){
            if(in[pa] > in[pb]){
                func(in[pa], in[a] + 1);
                a = parent[pa], pa = pathtop[a];
            }else{
                func(in[pb], in[b] + 1);
                b = parent[pb], pb = pathtop[b];
            }
        }
        if(in[a] > in[b]) swap(a, b);
        func(in[a], in[b] + 1);
    }
};
endsnippet
snippet cpp_int
#include <boost/multiprecision/cpp_int.hpp>
using cpp_int = boost::multiprecision::cpp_int;
endsnippet
